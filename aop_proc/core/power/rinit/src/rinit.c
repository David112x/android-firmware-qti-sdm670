/*===========================================================================
                                 rinit.c

DESCRIPTION:
  This file implements the APIs to initialize hardware blocks.

Copyright (c) 2016-2017 QUALCOMM Technologies, Inc. (QTI). All Rights Reserved.  
QUALCOMM Proprietary.  Export of this technology or software is regulated 
by the U.S. Government. Diversion contrary to U.S. law prohibited.
===========================================================================*/

//===========================================================================
//                      Includes and Variable Definitions
//===========================================================================

//---------------------------------------------------------------------------
// Include Files
//---------------------------------------------------------------------------
#include <string.h>
#include "rinit.h"
#include "CoreVerify.h"
#include "cmd_db.h"
#include "pwr_utils_lvl.h"
#include "page_select.h"
#include "aop_hwio.h"
#include "HALhwio.h"

//---------------------------------------------------------------------------
// Defines and Constants
//---------------------------------------------------------------------------
/* Various constants for interpreting Extension bit mask */
static const uint32 EXT_CODE_MASK = 0xFFFFF;
static const uint32 EXT_COUNT_MASK = 0xFF000000;
static const uint32 EXT_COUNT_SHIFT = 0x18;
static const uint32 EXT_FIELD_LEVEL_SHIFT = 0x14;
static const uint32 EXT_FIELD_SHIFT_MASK = 0xFF;
static const uint32 EXT_FIELD_WIDTH_MASK = 0xFF00;
static const uint32 EXT_FIELD_WIDTH_SHIFT = 0x8;

/* Checks if the extension intended at the field level */
#define EXT_AT_FIELD_LEVEL(ext_mask) (((ext_mask) >> EXT_FIELD_LEVEL_SHIFT) & 1)

/* Macro to get extension count */
#define EXT_COUNT(coded_ext) (((coded_ext) & EXT_COUNT_MASK) >> EXT_COUNT_SHIFT)

/* Macro to extract actual extension code */
#define EXT_CODE(coded_ext) ((coded_ext) & EXT_CODE_MASK)

/* Macros to extract field info while handling extension at field level */
#define EXT_FIELD_SHIFT(field_data) ((field_data) & EXT_FIELD_SHIFT_MASK)

#define EXT_FIELD_WIDTH(field_data) \
  (((field_data) & EXT_FIELD_WIDTH_MASK) >> EXT_FIELD_WIDTH_SHIFT)

#define EXT_FIELD_MASK(field_data)  ((1 << EXT_FIELD_WIDTH(field_data)) - 1)

#define EXT_FIELD_ADJ_VAL(val, field_data) \
  (((val) & EXT_FIELD_MASK(field_data)) << EXT_FIELD_SHIFT(field_data))

/* Macro that converts two uint32s to a string for CMD_DB queries */
#define RINIT_INTS_TO_STR(buffer, ptr0, ptr1) \
  { \
    memcpy (buffer, ptr0, sizeof(uint32));  \
    memcpy (buffer + sizeof(uint32), ptr1, sizeof(uint32)); \
    buffer[8] = 0;  \
  }

/* Register read write macros as per execution environment (target / pc) */
#ifndef PC_SIM
#define REG_READ(addr) reg_read (addr)
#define REG_WRITE(addr, val) reg_write (addr, val)
#else
#define REG_READ(addr) 0
#define REG_WRITE(addr, val) printf("Address: %p\tValue: 0x%x\n", addr, val)
#endif

//---------------------------------------------------------------------------
// Type definitions
//---------------------------------------------------------------------------
/* Enum containing various rinit extension codes */
enum
{
  EXT_MASKED_ASSIGN = 0x1,
  EXT_WAIT = 0x2,
  EXT_POLL = 0x3,
  EXT_MASKED_POLL = 0x4,
  EXT_HLVL = 0x5,
  EXT_VLVL = 0x6,
  EXT_VERSIONS = 0x7,
  EXT_VER_RANGE = 0x8,
  EXT_CMD_DB_ADDR = 0x10,
  EXT_CMD_DB_ADDR_IPCB = 0x11,
  EXT_MOD_HDR = 0x100
};

/* Enum for various properties in module's header */
enum
{
  MOD_ATTR_HDR_LEN = 0x1,
  MOD_ATTR_BLOB_LEN = 0x2,
  MOD_ATTR_VERSIONS = 0x10,
  MOD_ATTR_VERSION_RANGE = 0x11,
};

//---------------------------------------------------------------------------
// External References
//---------------------------------------------------------------------------
/* Autogenerated Rinit entries and count */
extern rinit_module_entry rinit_entries[];
extern const size_t rinit_entry_count;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------
/* Current chip version */
static uint32 hw_version;

//===========================================================================
//                       Function Defintions
//===========================================================================

//---------------------------------------------------------------------------
// Local Function Definitions
//---------------------------------------------------------------------------

/**
 * <!-- chip_version -->
 *
 * @brief Temporary function to return chip version until ChipInfo APIs become
 *        available.
 *
 * bits[8-15] - major version
 * bits[0-7] - minor version
 *
 * @return Integer representation for chip version.
 */
uint32 chip_version (void)
{
  volatile uint32 *ver_reg = (volatile uint32 *)TCSR_SOC_HW_VERSION;
  return ((*ver_reg) & 0xFFFF);
}

/**
 * <!-- rinit_process_mod_header -->
 *
 * @brief Processes module's header to check if blob that follows needs
 *        be written based on hw version, device id etc info embedded
 *        in the header.
 *
 * Module header properties' format:
 *   prop_code, prop_args
 *   header_len_code, header_len
 *   blob_len_code, blob_len
 *   version_range_code, min_ver, max_ver
 *   versions_code, N, ver0, ver1, ... , verN-1 (N count of versions specified) 
 *
 * @param header: Starting of module header
 *
 * @return number of vals/uint32 to jump after header processing
 *         - length of header if blob needs to be written (gives next addr,val)
 *         - length of header + length of blob, otherwise (jumps to next module)
 */
uint32 rinit_process_mod_header (uint32 *header)
{
  uint32 hdr_len;
  uint32 blob_len = (uint32)(-1);
  uint32 i;
  boolean write_blob = TRUE;

  CORE_VERIFY (header != NULL);
  CORE_VERIFY (header[0] == MOD_ATTR_HDR_LEN);

  hdr_len = header[1];
  for (i = 2; i < hdr_len; )
  {
    switch (header[i])
    {
      case MOD_ATTR_BLOB_LEN:
        blob_len = header[i+1];
        i += 2;
        break;

      case MOD_ATTR_VERSION_RANGE:
        if (hw_version < header[i+1] || header[i+2] < hw_version)
        {
          write_blob = FALSE;
        }
        i += 3;              /* code, min, max */
        break;

      case MOD_ATTR_VERSIONS:
        {
          uint32 count = header[i+1];
          uint32 j = 0;

          while ((header[(i+2)+j] != hw_version) && (++j < count));

          if (j >= count)    /* >= to handle count = 0, can't but still */
          {
            write_blob = FALSE;
          }
          i += 1 + 1 + count;     /* code, count, ver0, ver1, ... */
        }
        break;

      default:
        CORE_VERIFY (0);
        break;
    }
  }

  return (write_blob ? hdr_len : (hdr_len + blob_len));
}

/**
 * <!-- reg_read -->
 *
 * @brief Reads a CSR register
 *
 * @param addr - the address of the CSR register to read
 *
 * @return the value of the CSR register
 */
static uint32 reg_read (volatile uint32 *addr)
{
#ifdef RINIT_IN_DDR
  uint32 tmp = HWIO_AOP_PAGE_SELECT_IN;
  HWIO_AOP_PAGE_SELECT_OUT (0);
#endif
  
  uint32 ret = *addr;

#ifdef RINIT_IN_DDR
  HWIO_AOP_PAGE_SELECT_OUT (tmp);
#endif
  
  return ret;
}

/**
 * <!-- reg_write -->
 *
 * @brief Writes a CSR register
 *
 * @param addr - the address of the CSR register
 * @param val - the value to write
 *
 * @return none
 */
static void reg_write (volatile uint32 *addr, uint32 val)
{
#ifdef RINIT_IN_DDR
  uint32 tmp = HWIO_AOP_PAGE_SELECT_IN;
  HWIO_AOP_PAGE_SELECT_OUT (0);
#endif

  
  *addr = val;

#ifdef RINIT_IN_DDR
  HWIO_AOP_PAGE_SELECT_OUT (tmp);
#endif
}

/**
 * <!-- rinit_write_extended -->
 *
 * @brief Performs write with an additional operation like wait or poll.
 *
 * @Note This is an internal function and is expected to receive valid
 *       inputs. If it is shared outside, add extra error checking.
 *
 * @param values: Array containing address followed by value and extension
 *                arguments.
 *                values[0] = address, values[1] = actual_val, 
 *                value[2] = ext_code, value[3...] = arguments to extension
 * @param count: Count of values processed as part of extensions 
 *               (addr + init_val + num of exts + arguments for each exts).
 *
 * @return 0 if successful else rinit_err_t
 */
static int rinit_write_extended (uint32 *values, uint32 *count)
{
  volatile uint32 *address = (volatile uint32 *)(values[0] & ~1);
  boolean post_write = FALSE;
  boolean field_ext;
  boolean bail_write = FALSE;
  boolean init_val_update = FALSE;
  uint32 init_val = values[1];
  uint32 ext_code;
  uint32 ext_index = 2;
  uint32 ext_count = EXT_COUNT (values[ext_index]);
  uint32 ext_processed = 0;
  uint32 ext_res = 0;
  uint32 *args;
  uint32 i;
  char buffer[9];

  /* Extension handling */
  for (i = 0; i < 2; i++)         /* Pre and Post iterations */
  {
    ext_index = 2;
    for (ext_processed = 0 ; ext_processed < ext_count; ext_processed++)
    {
      ext_code = EXT_CODE (values[ext_index]);
      field_ext = EXT_AT_FIELD_LEVEL (values[ext_index]);
      args = &values[ext_index+1];        /* pointer to ext args */
      init_val_update = FALSE;

      switch (ext_code)
      {
        case EXT_MOD_HDR:
          if (post_write)
          {
            CORE_VERIFY(0);  /* Header should not go to post_write stage */
          }
          ext_index += rinit_process_mod_header(args) + 1; /*ext and ret_val */
          *count = ext_index;
          return RINIT_SUCCESS;

        case EXT_MASKED_ASSIGN:
          if (!post_write)          /* Pre write extension */
          {
            ext_res = ((REG_READ (address) & (~values[ext_index+1])) | 
                       (init_val & values[ext_index+1]));
            init_val_update = TRUE;
          }
          ext_index += 2;    /* ext and one arg */
          break;

        case EXT_CMD_DB_ADDR:
          if (!post_write)          /* Pre write extension */
          {
            RINIT_INTS_TO_STR (buffer, args, args+1);
            ext_res = cmd_db_query_addr (buffer) + args[2];
            init_val_update = TRUE;
          }
          ext_index += 4;    /* ext and three args */
          break;

        case EXT_CMD_DB_ADDR_IPCB:
          if (!post_write)          /* Pre write extension */
          {
            RINIT_INTS_TO_STR (buffer, args, args+1);
            ext_res = cmd_db_query_addr_ipcb (buffer) + args[2];
            init_val_update = TRUE;
          }
          ext_index += 4;    /* ext and three args */
          break;

        case EXT_HLVL:
        case EXT_VLVL:
          if (!post_write)          /* Pre write extension */
          {
            RINIT_INTS_TO_STR (buffer, args, args+1);
            ext_res = (ext_code == EXT_HLVL) ?
                        pwr_utils_hlvl_named_resource (buffer, args[2]):
                        pwr_utils_vlvl_named_resource (buffer, args[2]);

            if ((int)ext_res < 0)
            {
              return RINIT_EXT_ERR;
            }
            init_val_update = TRUE;
          }
          ext_index += 4;    /* ext and three args */
          break;

        case EXT_VERSIONS:
          if (!post_write)
          {
            uint32 j = 0;
            while ((hw_version != args[1+j]) && (++j < args[0]));

            if (j >= args[0])     /* >= if args[0] = 0, can't be but still */
            {
              bail_write = TRUE;
            }
          }
          ext_index += 2 + args[0];    /* ext, count, ver0, ver1, .., verN-1 */
          break;

        case EXT_VER_RANGE:
          if (!post_write)
          {
            if (hw_version < args[0] || args[1] < hw_version)
            {
              bail_write = TRUE;
            }
          }
          ext_index += 3;    /* ext and two args */
          break;

        case EXT_WAIT:
          if (post_write)
          {
            /* busy_wait (args[0]); */      /* Waiting for api */
          }
          ext_index += 2;    /* ext and one arg */
          break;

        case EXT_POLL:
          if (post_write)
          {
            while (*((volatile uint32 *)args[0]) != args[1]); /* Polling loop */
          }
          ext_index += 3;    /* ext and two args */
          break;

        case EXT_MASKED_POLL:
          if (post_write)
          {
            while ((*((volatile uint32 *)args[0]) & args[1]) != args[2]);
          }
          ext_index += 4;    /* ext and three args */
          break;

        default:
          /* Either error with code generation or a new extension added in Rinit
           * tool but is not yet handled here in the image (if so, add it). */
          CORE_VERIFY(0);
          break;
      }

      if (!post_write && init_val_update)
      {
        if (field_ext == TRUE)
        {
          init_val |= EXT_FIELD_ADJ_VAL(ext_res, values[ext_index]);
        }
        else
        {
          init_val = ext_res;
        }
      }

      if (field_ext == TRUE)
      {
        /* field ext check in above 'if' happens only during pre-write */
        ext_index += 1;       /* Field exts have one more arg */
      }
    }

    /* Finished first iteration - all pre extension are processed 
     * - write register and set flag for post write extensions */
    if (!post_write && !bail_write)
    {
      REG_WRITE (address, init_val);
      post_write = TRUE;
    }
  }

  *count = ext_index;        /* values consumed during extension processing */

  return RINIT_SUCCESS;
}


/**
 * <!-- rinit_write_vals -->
 *
 * @brief Writes the values for the input module at addresses specified 
 *        along other operations (extension) when indicated.
 *
 * @param entry: An entry of a HW block that will get initialized.
 *
 * @return 0 if the block got initialized successfully with input entry else
 *         rinit_err_t.
 */
static int rinit_write_vals (rinit_module_entry *entry)
{
  size_t i;
  uint32 *values;
  uint32 init_val;
  volatile uint32 *address;
  int ret_val = RINIT_SUCCESS;
  uint32 count = 0;

  if (entry == NULL)
  {
    /* Nothing to do - just return success */
    return ret_val;
  }

#ifdef RINIT_IN_DDR
  values = (uint32 *)set_ddr_access ((uint64_t)entry->values);
#else
  values = entry->values;
#endif
  
  for (i = 0; i < entry->count; )
  {
    address = (volatile uint32 *)values[i];
    init_val = values[i+1];

    if (((size_t)address & 0x1) == 0)
    {
      /* Regular write with no extensions */
      REG_WRITE (address, init_val);
      i += 2;                   /* Two values were consumed */
      continue;
    }
    
    /* A write with an extension */
    ret_val = rinit_write_extended (&values[i], &count);
    if (ret_val != 0)
    {
      break;                    /* Error with extended write - stop & return */
    }
    i += count;
  }

#ifdef RINIT_IN_DDR
  set_page_select (0);
#endif
  
  return ret_val;
}


//---------------------------------------------------------------------------
// Public Function Definitions
//---------------------------------------------------------------------------
/*
 * rinit_module_init
 */
int rinit_module_init (const char *name)
{
  size_t i;
  int ret_val;
  rinit_module_entry *entry;

  /* Can be queried just once at init time but we don't have RINIT specific
   * init, so query at module level - extremely light weight function */
  hw_version = chip_version();

  for (i = 0; i < rinit_entry_count; i++)
  {
    entry = &rinit_entries[i];
    if (strcmp (entry->name, name) == 0)
    {
      ret_val = rinit_write_vals (entry);
      return ret_val;
    }
  }

  return RINIT_UNKNOWN_MODULE;
}

