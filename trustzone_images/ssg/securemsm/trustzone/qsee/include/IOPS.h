#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"

// Copyright (c) 2017 Qualcomm Technologies, Inc.  All Rights Reserved.

// Qualcomm Technologies Proprietary and Confidential.

/**
 * @brief
 * Common definitions and APIs used for Output Protection
 */

/** Topology Info **/

typedef struct {
  uint32_t depth;
  uint32_t deviceCount;
  uint32_t maxDevicesExceeded;
  uint32_t maxCascadeExceeded;
  uint32_t hdcp2LegacyDeviceDownstream;
  uint32_t hdcp1DeviceDownstream;
} HdcpTopology;

#define IOPS_HDCP_LEVEL_0 UINT8_C(0x00)
#define IOPS_HDCP_LEVEL_1 UINT8_C(0x01)
#define IOPS_HDCP_LEVEL_2 UINT8_C(0x02)
#define IOPS_HDCP_LEVEL_3 UINT8_C(0x03)
#define IOPS_HDCP_LEVEL_4 UINT8_C(0x04)
#define IOPS_HDCP_LEVEL_5 UINT8_C(0x05)
#define IOPS_DRM_LOCAL_DISPLAY_ONLY UINT8_C(0x0F)
#define IOPS_NO_DIGITAL_OUTPUT UINT8_C(0xFF)
#define IOPS_HDCP_SRM_DEFAULT_VERSION UINT16_C(0)
#define IOPS_HDCP_TXMTR_HDMI UINT32_C(0x8001)
#define IOPS_HDCP_TXMTR_DP UINT32_C(0x8002)
#define IOPS_HDCP_TXMTR_WIFI UINT32_C(0x8003)
#define IOPS_HDCP_TXMTR_DSI0 UINT32_C(0x8004)
#define IOPS_HDCP_TXMTR_DSI1 UINT32_C(0x8005)
#define IOPS_ALL_EXT_DISP UINT32_C(0xffff)

#define IOPS_OP_getOPSVersion 0
#define IOPS_OP_getHDCPCapability 1
#define IOPS_OP_getDeviceTopology 2
#define IOPS_OP_getContentProtectionLevel 3

static inline int32_t
IOPS_release(Object self)
{
  return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IOPS_retain(Object self)
{
  return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t
IOPS_getOPSVersion(Object self, uint32_t *version_ptr)
{
  ObjectArg a[1];
  a[0].b = (ObjectBuf) { version_ptr, sizeof(uint32_t) };

  return Object_invoke(self, IOPS_OP_getOPSVersion, a, ObjectCounts_pack(0, 1, 0, 0));
}

static inline int32_t
IOPS_getHDCPCapability(Object self, uint8_t *currHdcpLevel_ptr, uint8_t *maxHdcpLevel_ptr)
{
  ObjectArg a[1];
  struct {
    uint8_t m_currHdcpLevel;
    uint8_t m_maxHdcpLevel;
  } o;
  a[0].b = (ObjectBuf) { &o, 2 };

  int32_t result = Object_invoke(self, IOPS_OP_getHDCPCapability, a, ObjectCounts_pack(0, 1, 0, 0));

  *currHdcpLevel_ptr = o.m_currHdcpLevel;
  *maxHdcpLevel_ptr = o.m_maxHdcpLevel;

  return result;
}

static inline int32_t
IOPS_getDeviceTopology(Object self, uint32_t deviceId_val, uint8_t *receiverIdList_ptr, size_t receiverIdList_len, size_t *receiverIdList_lenout, HdcpTopology *hdcpToplogy_ptr)
{
  ObjectArg a[3];
  a[0].b = (ObjectBuf) { &deviceId_val, sizeof(uint32_t) };
  a[1].b = (ObjectBuf) { receiverIdList_ptr, receiverIdList_len * sizeof(uint8_t) };
  a[2].b = (ObjectBuf) { hdcpToplogy_ptr, sizeof(HdcpTopology) };

  int32_t result = Object_invoke(self, IOPS_OP_getDeviceTopology, a, ObjectCounts_pack(1, 2, 0, 0));

  *receiverIdList_lenout = a[1].b.size / sizeof(uint8_t);

  return result;
}

static inline int32_t
IOPS_getContentProtectionLevel(Object self, uint8_t *cpl_ptr, uint8_t *epl_ptr, uint8_t *type_ptr)
{
  ObjectArg a[1];
  struct {
    uint8_t m_cpl;
    uint8_t m_epl;
    uint8_t m_type;
  } o;
  a[0].b = (ObjectBuf) { &o, 3 };

  int32_t result = Object_invoke(self, IOPS_OP_getContentProtectionLevel, a, ObjectCounts_pack(0, 1, 0, 0));

  *cpl_ptr = o.m_cpl;
  *epl_ptr = o.m_epl;
  *type_ptr = o.m_type;

  return result;
}



