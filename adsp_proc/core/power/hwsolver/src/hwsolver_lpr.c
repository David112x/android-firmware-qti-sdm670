/*============================================================================
@file hwsolver_lpr.c
 
Defines an LPR routine for the HWSolver that allows it to enable/disable
HW solver modes whenever solver constraints on the system changes
 
Copyright (c) 2016-2017 Qualcomm Technologies Incorporated.
All Rights Reserved.
Qualcomm Confidential and Proprietary
============================================================================*/

#include "hwsolver_internal.h"
#include "sleep_lpr.h"
#include "sleep_synth.h"
#include "q6_lpm_config.h"
#include "sleep_npa.h"

/*----------------------------------------------------------------------------
 * Externs
 * -------------------------------------------------------------------------*/

/* LPR Definitions generated by Sleep via HWSolver XML file */
extern sleep_lprm SleepLPR_hwsolver_modes[];
extern sleep_lpr  SleepLPR_hwsolver;

extern hwsolver_struct hwsolver;


/*----------------------------------------------------------------------------
 * Routines
 * -------------------------------------------------------------------------*/

/**
 * hwsolver_lpr_enter
 */
void hwsolver_lpr_enter( uint64 duration )
{
  npa_query_type result;
  int sw_restriction = 0xFFFFFFFF;
  int i;

  /* Get current latency restriction */
  CORE_VERIFY( 
    NPA_QUERY_SUCCESS == npa_query( hwsolver.latency_qh, 
                                    NPA_QUERY_CURRENT_STATE, &result ) );
                                    
  hwsolver.latency_val = result.data.state;
                                    
  /* Get current max_duration hint */
  CORE_VERIFY( 
    NPA_QUERY_SUCCESS == npa_query( hwsolver.max_duration_qh, 
                                    NPA_QUERY_CURRENT_STATE, &result ) );
  
  sw_restriction = MIN(hwsolver.latency_val, result.data.state);
                                    
  if ( sw_restriction != 0xFFFFFFFF )
  {
    /* Latency restriction for HW Solver = (current SW restriction - 
       latency of the chosen SW solved mode) */
    sw_restriction = 
      MAX(sw_restriction - synthLPRM_getConfiguringModeEnterExitLatency(), 1);
  }
  
  ULOG_RT_PRINTF_1( hwsolver.log, "hwsolver_lpr_enter (sw_restriction: %d)",
                    sw_restriction );
  
  for ( i = 0; i <= HWIO_SSC_RSCC_RSC_ID_DRVd_MAXd; ++i )
  {    
    hwsolver_toggle_modes_by_latency( i, sw_restriction );
  }
  
  /* Enable RSCp handshake */
  q6LPMConfig_setRpmhHandshake( 1 );
  
  ULOG_RT_PRINTF_0( hwsolver.log, "Enabled RSCp handshake" );
  
  /* Configure SSC HW Frame 0 - the one used by the solver */
  /* Set a high value in TVAL; the solver will overwrite */
  HWIO_SSC_QTMR_V1_CNTP_TVAL_0_OUT( 0x7fffffff );
  HWIO_SSC_QTMR_V1_CNTP_CTL_0_OUTM( HWIO_SSC_QTMR_V1_CNTP_CTL_0_IMSK_BMSK, 0 );
  HWIO_SSC_QTMR_V1_CNTP_CTL_0_OUTM( HWIO_SSC_QTMR_V1_CNTP_CTL_0_EN_BMSK, 
    1 << HWIO_SSC_QTMR_V1_CNTP_CTL_0_EN_SHFT );
}

/**
 * hwsolver_lpr_exit
 */
void hwsolver_lpr_exit( void )
{
  /* Disable RSCp handshake */
  q6LPMConfig_setRpmhHandshake( 0 );
  
  ULOG_RT_PRINTF_0( hwsolver.log, "Disabled RSCp handshake" );
}

/**
 * hwsolver_lpr_profile_exit
 */
uint64 hwsolver_lpr_profile_exit( sleepStats_timestamps *timeStamps, 
                                  sleep_lprm            *self,
                                  boolean                runAsCacheable )
{
  ULOG_RT_PRINTF_2( hwsolver.log, 
                    "hwsolver_lpr_profile_exit (last_timeslot: %d) (last_mode: %d)",
                    hwsolver_get_timeslot_chosen( 0 ),
                    hwsolver_get_mode_chosen( 0 ) );
                    
  return 500;
}

             
/**
 * @brief hwsolver_lpr_init
 * Init function for the HWSolver LPR. Signature is due to the fact that it
 * is an NPA resource available callback.
 */
void hwsolver_lpr_init( void *context, unsigned evt_type,
                        void *data, unsigned int data_size )
{
  sleepLPR_registerNodelessLPR( "hwsolver", SLEEP_ALL_LPRMS );  
  
  /* Disable RSCp handshake at init */
  q6LPMConfig_setRpmhHandshake( 0 );
  
  CORE_VERIFY_PTR(
    hwsolver.latency_qh = npa_create_query_handle( SLEEP_NORMAL_LATENCY_NODE_NAME ) );
    
  CORE_VERIFY_PTR(
    hwsolver.max_duration_qh = npa_create_query_handle( SLEEP_MAX_DURATION_NODE_NAME ) );
}
