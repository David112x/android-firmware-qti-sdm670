#ifndef __LOWI_REQUEST_H__
#define __LOWI_REQUEST_H__


/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

        LOWI Request Interface Header file

GENERAL DESCRIPTION
  This file contains the structure definitions and function prototypes for
  LOWIRequest

Copyright (c) 2012-2013 Qualcomm Atheros, Inc.
  All Rights Reserved.
  Qualcomm Atheros Confidential and Proprietary.

Copyright (c) 2017 Qualcomm Technologies, Inc.
All Rights Reserved.
Qualcomm Technologies Proprietary and Confidential.

=============================================================================*/
#include "lowi_const.h"
#include "lowi_mac_address.h"
#include "lowi_service_v01.h"
#include "lowi_client_handle.h"
#include "vector.h"

namespace qc_loc_fw
{

// Indicates, to provide the cached data only from the last scan results
// Comes as part of the measAgeFilter in request
// Only valid for cache fall-back request
#define LOWI_LATEST_SCAN_RESULTS_MASK 0xFFFFFFFF

// QMI interface allows the fall-back time to be in seconds.
// This mask allows the clients to indicate, if the fall-back time
// should be treated as msec instead.
#define LOWI_MSEC_MASK 0x80000000

/**
 * Base class for all requests LOWI can handle
 */
class LOWIRequest
{
protected:
  static const char* const TAG;
private:
  eSupportedServiceVersion mRequestVersion;
  uint32 mClientId;

public:
  /** Type of Request*/
  enum eRequestType
  {
    DISCOVERY_SCAN,
    RANGING_SCAN,
    CAPABILITY,
    RESET_CACHE,
    ASYNC_DISCOVERY_SCAN_RESULTS,
    WLAN_EVENTS_SUBSCRIPTION,
    WLAN_EVENTS_QUERY,
    BATCHING_SUBSCRIPTION,
    BATCHING_RESULTS,
    BGSCAN_SUBSCRIPTION,
    BGSCAN_RESULTS,
    EXT_RANGING_RESULTS_REQ
  };

public:

  /**
   * Constructor
   * @param eSupportedServiceVersion Version for this request.
   *  This can be different for different major version of the QMI service
   * @param uint32 Unique ID of the Client who made this request
   */
  LOWIRequest (eSupportedServiceVersion version, uint32 client_id);

  /** Destructor*/
  virtual ~LOWIRequest () = 0;

  /** Copy Constructor */
  LOWIRequest( const LOWIRequest& rhs );
  /** Assignment operator */
  LOWIRequest& operator=( const LOWIRequest& rhs );

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  virtual uint32 getRequestId () const = 0;

  /**
   * Returns the Client ID for the client who made this request
   * @return Unique ID of the Client who made this request
   */
  virtual uint32 getClientId () const;

  /**
   * Returns the request version
   * @return Request version
   */
  virtual eSupportedServiceVersion getRequestVersion () const;

  /**
   * Returns the request type
   * @return eRequestType type of request
   */
  virtual eRequestType getRequestType () const = 0;

  /**
  * Returns the Originator of the request if available
  * @ return char* String with the name or NULL
  */
  virtual const char* getRequestOriginator () const = 0;

};

///////////////////////////
// Capability Request
///////////////////////////

/**
 * Capability Request
 */
class LOWICapabilityRequest: public LOWIRequest
{
private:
#if !APSS
  QmiLowiCapabilitiesRequest_v01 mCapabilityRequest;
#endif

public:

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiCapabilitiesRequest_v01* Request message
   */
  LOWICapabilityRequest (uint32 client_id,
      QmiLowiCapabilitiesRequest_v01* req);

  /** Destructor*/
  virtual ~LOWICapabilityRequest ();

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mCapabilityRequest.clientName_valid ? mCapabilityRequest.clientName : NULL;
  }
};

///////////////////////////
// Discovery scan Request
///////////////////////////

/**
 * Class to make a Discovery scan request
 */
class LOWIDiscoveryScanRequest: public LOWIRequest
{
public:
  /** Defines the available type of Discovery Scan*/
  enum eScanType
  {
    /**Passive Scan*/
    PASSIVE_SCAN,
    /**Active Scan*/
    ACTIVE_SCAN
  };

  /** Defines the available mode of Discovery Scan Request*/
  enum eRequestMode
  {
    /** Request to perform a Fresh scan. The request will trigger a Request
     * being sent to WifiDriver for fresh scan */
    FORCED_FRESH,
    /** Request to perform Fresh scan with throttling. If the last fresh
     * scan results are relatively fresh then this Request will be serviced
     * from Cache. Criteria to determine freshness is
     * current time < last scan time + threshold (defined in config file)
     */
    NORMAL,
    /** Request to return the result from Cache*/
    CACHE_ONLY,
    /** Request to provide the result from Cache but if results
     * are not found in cache then start the fresh scan*/
    CACHE_FALLBACK
  };

  /** Defines the bands for which the Discovery Scan Request can be made*/
  enum eBand
  {
    /** 2.4 Ghz only*/
    TWO_POINT_FOUR_GHZ,
    /** 5 Ghz only*/
    FIVE_GHZ,
    /** Both (2.5 & 5 Ghz)*/
    BAND_ALL
  };

  /**
   * Returns the scan type
   * @return Passive scan or Active scan
   */
  eScanType getScanType () const;
  /**
   * Returns the request mode
   * @return Mode of request
   */
  eRequestMode getRequestMode () const;
  /**
   * Returns Measurement age filter in milli seconds.
   * For Cache Request, at the time of generating the
   *  response for the request, all the measurements which
   *  are older than Current time - filter age,
   *  will be filtered out from the response.
   *  So '0' age filter could potentially
   *  return no measurements from the cache.
   *
   * For Fresh scan Request, at the time of generating the
   *  response for the request, all the measurements which
   *  are older than Request time to WLAN driver - filter age,
   *  will be filtered out from the response.
   *
   * Note:
   * For Cache Fall Back Request, Client can send a
   * Meas Age Filter as 0xFFFF to indicate to provide only
   * the last scan results. In that case, this API
   * provides the 0 as the filter age.
   *
   * @return Measurement age in msec
  */
  uint32 getMeasAgeFilterMSec () const
  {
    uint32 age = 0;
    if (!(mDiscoveryrequest->measAgeFilterSec & LOWI_LATEST_SCAN_RESULTS_MASK))
    {
      age = mDiscoveryrequest->measAgeFilterSec* 1000;
    }
	return age;
  }

  /**
  * Indicates if the Last scan results are to be returned as part of
  * the cache fallback request only.
  * Note: Applicable to only cash fallback request
  * MeasAgeFilter can contain 0xFFFF from a client to indicate if
  * client wants the last scan reults only if the results could
  * be provided from the cache
  */
  bool getlastScanResults () const
  {
    bool retVal = false;
    if (mDiscoveryrequest->measAgeFilterSec & LOWI_LATEST_SCAN_RESULTS_MASK)
    {
      retVal = true;
    }
	return retVal;
  }

  /**
  * Returns the Fallback tolerance in Msec
  *
  * Only valid when eRequestMode is CACHE_FALLBACK.
  * At the time of evaluating this request, all the
  * requested channels should have last measurement
  * timestamp equal to or greater than Current time -
  * Fallback tolerance. If not, then fallback to
  * trigger a fresh scan. Client can provide 0 if they
  * want to trigger a fresh scan as well.
  *
  * QMI has the fallback tolerance in seconds
  * We are using the top most bit to indicate, if the tolerance is to be
  * treated in sec or msec
  * if MSB is set to 1, treat it as msec otherwise sec
  * @return Cache fallback tolerance
  */
  uint32 getFallbackToleranceMSec () const
  {
    if (mDiscoveryrequest->fallbackToleranceSec & LOWI_MSEC_MASK)
    {
      return (mDiscoveryrequest->fallbackToleranceSec & ~LOWI_MSEC_MASK);
    }
	else
	{
	  // Convert to Msec
	  return (mDiscoveryrequest->fallbackToleranceSec * 1000);
	}
  }

  /**
   * Returns the band
   * @return RF band to scan.
   */
  eBand getBand () const;
  /**
   * Returns the dynamic array containing the list of frequencies
   * to be scanned.
   * Number of entries in the vector should not be more than
   * MAX_CHAN_INFO_SIZE as that's the max LOWI supports as of
   * now. Any ChannelInfo more than MAX_CHAN_INFO_SIZE will be
   * ignored.
   * @return bool indicating if the freq list is available or not
   */
  bool getChannels (vector <uint32>& freq);

  /** Destructor*/
  virtual ~LOWIDiscoveryScanRequest ();

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    char* retVal = NULL;
	if (mDiscoveryrequest)
	{
		retVal = mDiscoveryrequest->clientName_valid ? mDiscoveryrequest->clientName : NULL;
	}
	return retVal;
  }

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiDiscoveryRequest_v01* request message
   */
  LOWIDiscoveryScanRequest (uint32 client_id,
      QmiLowiDiscoveryRequest_v01* request);

  /**
   * Discovery scan request
   */
  QmiLowiDiscoveryRequest_v01* mDiscoveryrequest;

};


/**
 * Defines the info for a Channel
 */
class LOWIChannelInfo
{
private:
  /** Frequency in Mhz*/
  uint32 frequency;
public:
  LOWIChannelInfo ();
  /**
   * Constructor
   * @param uint32 frequency of the channel
   */
  LOWIChannelInfo (uint32 freq);

  /**
   * Constructor
   * @param uint32 Channel number
   * @param LOWIDiscoveryScanRequest::eBand band of the channel
   */
  LOWIChannelInfo (uint32 channel, LOWIDiscoveryScanRequest::eBand band);

  ~LOWIChannelInfo ();
  /**
   * Returns the band associated with the channel.
   * @return Band for the channel.
   */
  LOWIDiscoveryScanRequest::eBand getBand () const;
  /**
   * Returns the Frequency associated with the channel.
   * @return Frequency of the channel
   */
  uint32 getFrequency () const;
  /**
   * Returns the Channel number for the Channel Info.
   * Channel number corresponds to the Band
   *
   * @return Channel Number
   */
  uint32 getChannel () const;
};


///////////////////////////
// Ranging scan Request
///////////////////////////

/** Defines available type of Wifi Nodes*/
typedef eQmiLowiNodeType_v01 eNodeType;
#define NODE_TYPE_UNKNOWN LOWI_NODE_TYPE_UNKNOWN_V01
#define ACCESS_POINT LOWI_ACCESS_POINT_V01
#define PEER_DEVICE LOWI_PEER_DEVICE_V01
#define NAN_DEVICE LOWI_NAN_DEVICE_V01
#define STA_DEVICE LOWI_STA_DEVICE_V01
#define SOFT_AP LOWI_SOFT_AP_V01

#if 0
enum eNodeType
{
	NODE_TYPE_UNKNOWN = 0,
	ACCESS_POINT, // access point
	PEER_DEVICE,  // device which is part of a p2p group
	NAN_DEVICE,   // device which is part of a NAN
	STA_DEVICE,   // stand alone station (as in ad-hoc BSS)
	SOFT_AP 	  // Node in Hotspot mode
};
/** Defines supported RTT types for Ranging scan request */

enum eRttType
{
  RTT1_RANGING = 0,    /* Ranging with no Multipath correction */
  RTT2_RANGING,        /* Ranging with Multipath correction */
  RTT3_RANGING,        /* Two-sided Ranging as defined in 802.11mc spec */
  BEST_EFFORT_RANGING  /* One of the above, which ever the peer supports */
};
#endif
typedef eRangingType_v01 eRttType;
#define RTT1_RANGING SINGLE_SIDED_RANGING_V01
#define RTT2_RANGING SINGLE_SIDED_RANGING_V01
#define RTT3_RANGING TWO_SIDED_RANGING_V01
#define BEST_EFFORT_RANGING BEST_EFFORT_RANGING_V01

/** Defines RTT report types for Ranging scan */
enum eRttReportType
{
  RTT_REPORT_1_FRAME_CFR = 0,  /* Responses sent on a per frame basis with CFR capture */
  RTT_REPORT_1_FRAME_NO_CFR,   /* Responses sent on a per frame basis without CFR captiure */
  RTT_REPORT_AGGREGATE         /* Single responses containing results for all requested APs and frames*/
};

/** Defines the Bandwidth for Ranging scan */
#if 0
enum eRangingBandwidth
{
  BW_20MHZ = 0,
  BW_40MHZ,
  BW_80MHZ,
  BW_160MHZ,
  BW_MAX
};

/** Defines the Preamble for Ranging scan */
enum eRangingPreamble
{
  RTT_PREAMBLE_LEGACY = 0,
  RTT_PREAMBLE_HT,
  RTT_PREAMBLE_VHT,
  RTT_PREAMBLE_MAX
};
#endif
typedef eRangingBandwidth_v01 eRangingBandwidth;
#define BW_20MHZ    BW_20MHZ_V01
#define BW_40MHZ	BW_40MHZ_V01
#define BW_80MHZ    BW_80MHZ_V01
#define BW_160MHZ   BW_160MHZ_V01
#define BW_MAX      (BW_160MHZ+1)

typedef eRangingPreamble_v01 eRangingPreamble;
#define RTT_PREAMBLE_LEGACY    RANGING_PREAMBLE_LEGACY_V01
#define RTT_PREAMBLE_HT        RANGING_PREAMBLE_HT_V01
#define RTT_PREAMBLE_VHT       RANGING_PREAMBLE_VHT_V01
#define RTT_PREAMBLE_MAX       (RTT_PREAMBLE_VHT+1)


/** This enum defines the Phy mode */
enum eLOWIPhyMode
{
  LOWI_PHY_MODE_UNKNOWN       = -1,
  LOWI_PHY_MODE_11A           = 0,  /* 11a Mode */
  LOWI_PHY_MODE_11G           = 1,  /* 11b/g Mode */
  LOWI_PHY_MODE_11B           = 2,  /* 11b Mode */
  LOWI_PHY_MODE_11GONLY       = 3,  /* 11g only Mode */
  LOWI_PHY_MODE_11NA_HT20     = 4,  /* 11na HT20 mode */
  LOWI_PHY_MODE_11NG_HT20     = 5,  /* 11ng HT20 mode */
  LOWI_PHY_MODE_11NA_HT40     = 6,  /* 11na HT40 mode */
  LOWI_PHY_MODE_11NG_HT40     = 7,  /* 11ng HT40 mode */
  LOWI_PHY_MODE_11AC_VHT20    = 8,  /* 5G 11ac VHT20 mode */
  LOWI_PHY_MODE_11AC_VHT40    = 9,  /* 5G 11ac VHT40 mode */
  LOWI_PHY_MODE_11AC_VHT80    = 10, /* 5G 11ac VHT80 mode */
  LOWI_PHY_MODE_11AC_VHT20_2G = 11, /* 2G 11ac VHT20 mode */
  LOWI_PHY_MODE_11AC_VHT40_2G = 12, /* 2G 11ac VHT40 mode */
  LOWI_PHY_MODE_11AC_VHT80_2G = 13, /* 2G 11ac VHT80 mode */
  LOWI_PHY_MODE_11AC_VHT80_80 = 14, /* 5G 11ac VHT80_80 mode */
  LOWI_PHY_MODE_11AC_VHT160   = 15, /* 5G 11ac VHT160 mode */
  LOWI_PHY_MODE_11AX_HE20     = 16, /* 5G 11ax HE20 mode */
  LOWI_PHY_MODE_11AX_HE40     = 17, /* 5G 11ax HE40 mode */
  LOWI_PHY_MODE_11AX_HE80     = 18, /* 5G 11ax HE80 mode */
  LOWI_PHY_MODE_11AX_HE80_80  = 19, /* 5G 11ax HE80_80 mode */
  LOWI_PHY_MODE_11AX_HE160    = 20, /* 5G 11ax HE160 mode */
  LOWI_PHY_MODE_11AX_HE20_2G  = 21, /* 2G 11ax HE20 mode */
  LOWI_PHY_MODE_11AX_HE40_2G  = 22, /* 2G 11ax HE40 mode */
  LOWI_PHY_MODE_11AX_HE80_2G  = 23, /* 2G 11ax HE80 mode */

  LOWI_PHY_MODE_MAX           = LOWI_PHY_MODE_11AX_HE80_2G
};


/**
 * Defines the information for a Wifi Node
 */
struct LOWINodeInfo
{
private:
  sLOWIRangingNodeInfo_v01 mRangingNode;
public:
  #define FTM_SET_ASAP(x) (x = (x | FTM_ASAP_BIT_V01))
  #define FTM_CLEAR_ASAP(x) (x = (x & ~(FTM_ASAP_BIT_V01)))
  #define FTM_GET_ASAP(x) ((x & FTM_ASAP_BIT_V01) ? 1 : 0)

  #define FTM_SET_LCI_REQ(x) (x = (x | FTM_LCI_BIT_V01))
  #define FTM_CLEAR_LCI_REQ(x) (x = (x & ~FTM_LCI_BIT_V01))
  #define FTM_GET_LCI_REQ(x) ((x & FTM_LCI_BIT_V01) ? 1 : 0)

  #define FTM_SET_LOC_CIVIC_REQ(x) (x = (x | FTM_LOC_CIVIC_BIT_V01))
  #define FTM_CLEAR_LOC_CIVIC_REQ(x) (x = (x & ~FTM_LOC_CIVIC_BIT_V01))
  #define FTM_GET_LOC_CIVIC_REQ(x) ((x & FTM_LOC_CIVIC_BIT_V01) ? 1 : 0)

  #define FTM_SET_PTSF_TIMER_NO_PREF(x) (x = (x | FTM_PTSF_TIMER_NO_PREF_V01))
  #define FTM_CLEAR_PTSF_TIMER_NO_PREF(x) (x = (x & ~FTM_PTSF_TIMER_NO_PREF_V01))
  #define FTM_GET_PTSF_TIMER_NO_PREF(x) ((x & FTM_PTSF_TIMER_NO_PREF_V01) ? 1: 0)

  #define FTM_SET_LEG_ACK_ONLY(x) (x = (x | FTM_LEG_ACK_ONLY_V01))
  #define FTM_CLEAR_LEG_ACK_ONLY(x) (x = (x & ~FTM_LEG_ACK_ONLY_V01))
  #define FTM_GET_LEG_ACK_ONLY(x) ((x & FTM_LEG_ACK_ONLY_V01) ? 1 : 0)

public:
  void setBssid (LOWIMacAddress& mac)
  {
  	mRangingNode.bssid.hi24 = mac.getHi24();
	mRangingNode.bssid.lo24 = mac.getLo24();
  }
  	
  LOWIMacAddress getBssid () const
  {
    return LOWIMacAddress (mRangingNode.bssid.hi24, mRangingNode.bssid.lo24);
  }
  void setFrequency (uint32 freq)
  {
    mRangingNode.frequency = freq;
  }
  uint32 getFrequency () const
  {
    return mRangingNode.frequency;
  }
  void setBandCenterFreq1 (uint32 freq)
  {
    mRangingNode.bandCenterFreq1 = freq;
  }
 
  uint32 getBandCenterFreq1 () const
  {
    return mRangingNode.bandCenterFreq1;
  }

  void setBandCenterFreq2 (uint32 freq)
  {
    mRangingNode.bandCenterFreq2 = freq;
  }
 
  uint32 getBandCenterFreq2 () const
  {
    return mRangingNode.bandCenterFreq2;
  }
  
  void setNodeType (eNodeType type)
  {
    mRangingNode.nodeType = type;
  }
  eNodeType getNodeType () const
  {
    return mRangingNode.nodeType;
  }
  void setSpoofBssid (LOWIMacAddress& mac)
  {
  	mRangingNode.spoofMacId.hi24 = mac.getHi24();
	mRangingNode.spoofMacId.lo24 = mac.getLo24();
  }
  LOWIMacAddress getSpoofBssid () const
  {
	return LOWIMacAddress (mRangingNode.spoofMacId.hi24, mRangingNode.spoofMacId.lo24);
  }
  void setRangingType (eRttType type)
  {
    mRangingNode.rangingType = type;
  }
  eRttType getRangingType () const
  {
	return mRangingNode.rangingType;
  }

  void setBandwidth (eRangingBandwidth bw)
  {
    mRangingNode.bandwidth = bw;
  }
  eRangingBandwidth getBandwidth () const
  {
	return mRangingNode.bandwidth;
  }
  	
  void setNumBurstExponent (uint8 exp)
  {
    mRangingNode.numBurstExponent = exp;
  }
  uint8 getNumBurstExponent () const
  {
	return mRangingNode.numBurstExponent;
  }
  void setBurstDuration (uint8 dur)
  {
    mRangingNode.burstDuration = dur;
  }
  uint8 getBurstDuration () const
  {
	return mRangingNode.burstDuration;
  }
  void setBurstPeriod (uint16 period)
  {
    mRangingNode.burstPeriod = period;
  }
  uint16 getBurstPeriod () const
  {
	return mRangingNode.burstPeriod;
  }
  void setPreamble (eRangingPreamble preemble)
  {
    mRangingNode.preamble = preemble;
  }
  eRangingPreamble getPreamble () const
  {
	return mRangingNode.preamble;
  }
  void setNumPktsPerMeas (uint8 pkts)
  {
    mRangingNode.numPktsPerMeas = pkts;
  }
  uint8 getNumPktsPerMeas () const
  {
	return mRangingNode.numPktsPerMeas;
  }
  void setNumRetriesPerMeas (uint8 retry)
  {
    mRangingNode.numRetriesPerMeas = retry;
  }
  uint8 getNumRetriesPerMeas () const
  {
	return mRangingNode.numRetriesPerMeas;
  }
  bool useChInfoFromCache () const
  {
    return (mRangingNode.useFromCache & LOWI_USE_CH_INFO_FRM_CACHE_BIT_V01);
  }
  bool useBWFromCache () const
  {
    return (mRangingNode.useFromCache & LOWI_USE_BW_FRM_CACHE_BIT_V01);
  }
  bool usePreambleFromCache () const
  {
    return (mRangingNode.useFromCache & LOWI_USE_PREAMBLE_FRM_CACHE_BIT_V01);
  }
  
  uint64 getFtmRangingParameters () const
  {
    return mRangingNode.ftmRangingOptions;
  }
  
public:
  /**
   * Constructor
   */
  LOWINodeInfo ()
  {
    memset (&mRangingNode, 0, sizeof (sLOWIRangingNodeInfo_v01));
  }

  /**
   * Constructor
   */
  LOWINodeInfo (sLOWIRangingNodeInfo_v01& node)
  {
    mRangingNode = node;
  }

  /**
   * Validates the NodeInfo
   */
  void validate ();

  /**
   * Copy constructor
   */
  LOWINodeInfo(const LOWINodeInfo& rhs)
  {
    mRangingNode = rhs.mRangingNode;
  }

  /**
   * Operator "="
   */
  LOWINodeInfo& operator=( const LOWINodeInfo& rhs )
  {
    mRangingNode = rhs.mRangingNode;
	return *this;
  }
};

/**
 * Class to make a Ranging scan request.
 */
class LOWIRangingScanRequest: public LOWIRequest
{
private:
  /**
   * Ranging request
   */
  QmiLowiRangingRequest_v01 mRequest;
  /**
   * Dynamic array containing the wifi Node Info to be scanned.
   * Currently LOWI only supports 16 wifi nodes to be scanned
   * with Ranging scan. Any thing more than 16 will be ignored.
   */
  vector <LOWINodeInfo> nodeInfo;
public:

  /**
   * Returns the Dynamic array containing the LOWINodeInfo
   * @return Dynamic array containing the LOWINodeInfo
   */
  vector <LOWINodeInfo> & getNodes ()
  {
    return this->nodeInfo;
  }

  /**
   * Constructor
   *
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiRangingRequest_v01* request
   */
  LOWIRangingScanRequest (
      uint32 client_id,
      QmiLowiRangingRequest_v01* request);

  /** Destructor*/
  virtual ~LOWIRangingScanRequest ()
  {
  }

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const
  {
    return RANGING_SCAN;
  }

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const
  {
    return this->mRequest.requestId;
  }

  bool getDetailedResult () const
  {
    bool retVal = false;
	if (mRequest.reportType_valid && (mRequest.reportType >= LOWI_RANGING_REPORT_DETAILED_V01))
	{
	  retVal = true;
	}
    return retVal;
  }

  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }

};

/**
 * Class to make a subscription Request for snoop scans.
*/
class LOWIAsyncDiscoveryScanResultRequest : public LOWIRequest
{
private:
  QmiLowiSnoopScanSubscriptionRequest_v01 mRequest;

public:
  /**
   * Constructor
   * A client registers this request to receive the discovery
   * scan results as and when they are available.
   * LOWI provides the snoop scan results to the client for as long
   * as the subscriptions iv not canceled or the request time is not
   * expired. After the request timer expiry the request will be dropped
   * silently and no more indications are sent to clients.
   *
   * Client will not get the results / response to this request
   * if there was a discovery scan result available but was
   * triggered by a discovery scan request from the same client.
   *
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiSnoopScanSubscriptionRequest_v01* request
   */
  LOWIAsyncDiscoveryScanResultRequest (
      uint32 client_id,
      QmiLowiSnoopScanSubscriptionRequest_v01* request);

  /**
   * Returns the expiry time of the Request in sec.
   * @return uint32 Request expiry time
   */
  uint32 getRequestExpiryTime ();

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Checks if only scans are to be sent, not sent to APSS.
   * @return bool true to only send scans not sent to APSS,
   *  false to send all scans
   */
  bool isSendScansNotSentToApss ();

  /**
   * Returns the state (Subscribe / Unsubscribe request)
   * @return true for subscription, false for unsubscribe
   */
  bool isSubscriptionRequest ();

  /**
   * Sets the subscription state
   * @param bool true to subscribe, false to cancel subscription
   */
  void setSubscriptionState (bool subscribe);

  /**
   * Creates a Dummy async Request for internal usage.
   * This is the request used by LOWIController internally to subscribe
   * for the LOWIAsyncDiscoveryScanResultRequest to WLAN Driver.
   */
  static LOWIAsyncDiscoveryScanResultRequest* createDummyAsyncRequest ();


  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }

};

/**
 * Class to make a subscription Request for WLAN Events.
*/
class LOWIWLANEventsSubscriptionRequest : public LOWIRequest
{
public:
  QmiLowiWlanInterfaceEventsSubscriptionRequest_v01 mRequest;

  /**
   * A client registers this request to receive the wlan events
   * LOWI provides the WLAN events to the clients for as long
   * as the subscriptions is not canceled.
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiWlanInterfaceEventsSubscriptionRequest_v01* request
   */
  LOWIWLANEventsSubscriptionRequest (uint32 client_id,
      QmiLowiWlanInterfaceEventsSubscriptionRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /**
   * Returns the state (Subscribe / Unsubscribe request)
   * @return true for subscription, false for unsubscribe
   */
  bool isSubscriptionRequest ();


  /**
   * Sets the subscription state
   * @param bool true to subscribe, false to cancel subscription
   */
  void setSubscriptionState (bool subscribe);

  /**
   * Creates a Dummy Events subscription Request for internal usage.
   * This is the request used by LOWIController internally to subscribe
   * for LOWIWLANEventsSubscriptionRequest to WLAN Driver.
   */
  static LOWIWLANEventsSubscriptionRequest* createDummyEventsSubscriptionRequest ();

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }
};

/**
 * Request to query a WLAN state.
*/
class LOWIWLANStateQueryRequest : public LOWIRequest
{
private:
  QmiLowiWlanInterfaceEventTriggerRequest_v01 mRequest;

public:
  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiWlanInterfaceEventTriggerRequest_v01* request
   */
  LOWIWLANStateQueryRequest (uint32 client_id,
      QmiLowiWlanInterfaceEventTriggerRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }
};

/**
 * Request to subscribe for Batching.
*/
class LOWIBatchingSubscriptionRequest : public LOWIRequest
{

public:
  QmiLowiBatchingSubscriptionRequest_v01 mRequest;

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiBatchingSubscriptionRequest_v01* request
   */
  LOWIBatchingSubscriptionRequest (uint32 client_id,
      QmiLowiBatchingSubscriptionRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /** Destructor*/
  virtual ~LOWIBatchingSubscriptionRequest ();

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }
};

/**
 * Request to get the Batching results.
*/
class LOWIGetBatchingResultsRequest : public LOWIRequest
{

public:
  QmiLowiGetBatchingResultsRequest_v01 mRequest;

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiGetBatchingResultsRequest_v01* request
   */
  LOWIGetBatchingResultsRequest (uint32 client_id,
      QmiLowiGetBatchingResultsRequest_v01* request);

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const;

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  /** Destructor*/
  virtual ~LOWIGetBatchingResultsRequest ();

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }
};

/**
 * Request to subscribe for BGScan.
*/
class LOWIBGScanSubscriptionRequest : public LOWIBatchingSubscriptionRequest
{

public:
  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiBatchingSubscriptionRequest_v01* request
   */
  LOWIBGScanSubscriptionRequest (uint32 client_id,
      QmiLowiBatchingSubscriptionRequest_v01* request);

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }
};

/**
 * Request to get the BGScan results.
*/
class LOWIGetBGScanResultsRequest : public LOWIGetBatchingResultsRequest
{

public:

  /**
   * Constructor
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiGetBatchingResultsRequest_v01* request
   */
  LOWIGetBGScanResultsRequest (uint32 client_id,
      QmiLowiGetBatchingResultsRequest_v01* request);

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const;

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }
};

/**
 * Class to request extended ranging results.
 */
class LOWIExtRangingResultsRequest: public LOWIRequest
{
private:
  /**
   * Request
   */
  QmiLowiExtRangingResultsRequest_v01 mRequest;

public:
	vector <LOWIMacAddress> bssid_list;

  /**
   * Constructor
   *
   * @param uint32 Unique ID of the Client who made this request
   * @param QmiLowiRangingRequest_v01* request
   */
  LOWIExtRangingResultsRequest (
      uint32 client_id,
      QmiLowiExtRangingResultsRequest_v01* request);

  /** Destructor*/
  virtual ~LOWIExtRangingResultsRequest ()
  {
    bssid_list.flush();
  }

  /**
   * Returns the request type
   * @return eRequestType type of the Request
   */
  virtual eRequestType getRequestType () const
  {
    return EXT_RANGING_RESULTS_REQ;
  }

  /**
   * Returns the RequestId
   * @return RequestId generated by the user of the API
   */
  uint32 getRequestId () const
  {
    return this->mRequest.requestId;
  }

  
  /**
   * Returns the Originator of the request if available
   * @ return char* String with the name or NULL
   */
  virtual const char* getRequestOriginator () const
  {
    return mRequest.clientName_valid ? mRequest.clientName : NULL;
  }

  bool isLciRequested()
  {
    if (mRequest.params_valid)
      return (mRequest.params & LOWI_EXT_RANGING_RESULTS_LCI_V01);
    else
      return false;
  }

   bool isLcrRequested()
  {
    if (mRequest.params_valid)
      return (mRequest.params & LOWI_EXT_RANGING_RESULTS_LCR_V01);
    else
      return false;
  }

  bool isColocatedBssRequested()
  {
    if (mRequest.params_valid)
      return (mRequest.params & LOWI_EXT_RANGING_RESULTS_COLOCATED_V01);
    else
      return false;
  }

  uint64_t getExtRttReqMask()
  {
    if (mRequest.params_valid)
	  return mRequest.params;
	else
	  return 0;
  }

};

} // namespace qc_loc_fw

#endif //#ifndef __LOWI_REQUEST_H__
