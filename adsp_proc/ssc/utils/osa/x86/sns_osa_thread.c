/*============================================================================
  @file sns_osa_thread.c

  @brief
  OS Abstraction layer for Sensors.

  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
  ============================================================================*/

/*============================================================================
  INCLUDES
  ============================================================================*/
#define _GNU_SOURCE
#include <limits.h>
#include <pthread.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>

#include "sns_assert.h"
#include "sns_isafe_list.h"
#include "sns_mem_util.h"
#include "sns_memmgr.h"
#include "sns_osa_lock.h"
#include "sns_osa_thread.h"
#include "sns_printf_int.h"
#include "sns_rc.h"
#include "sns_types.h"


/*============================================================================
  Macros
  ============================================================================*/

#define ROUND_UP(N, S) (((((size_t)(N)) + ((size_t)(S) ) - 1) / ((size_t)(S) )) * ((size_t)(S) ))
#define STACK_GUARD_SIZE sysconf(_SC_PAGESIZE)

/*============================================================================
  Typedefs
  ============================================================================*/

typedef struct
{
  /* List item. All qurt threads are maintained in sns_osa_threads */
  sns_isafe_list_item list_entry;
  /* Thread ID. This is generated by QuRT. */
  pthread_t thread_id;
  /* OS signals for this thread */
  pthread_cond_t signals;
  /* Mutex protecting OS signals for this thread */
  pthread_mutex_t mutex;
  /* Flags */
  sns_osa_thread_sigs flags;
  /* User information */
  void *info;
} sns_osa_thread_x86;

typedef struct
{
  /* pthread attributes */
  pthread_attr_t pthread_attrib;
  char name[SNS_OSA_THREAD_NAME_MAX_LEN];
  void *real_stack;
  void *user_info;
} sns_osa_thread_x86_attr;

/*============================================================================
  static Data
  ============================================================================*/

/* A list of all threads. Used to identify current thread */
static struct sns_isafe_list sns_osa_threads;
static sns_osa_lock *sns_osa_threads_lock;

/*============================================================================
  static Functions
  ============================================================================*/

/*!
  @brief Returns the current thread

  @return
  thread pointer if thread was found in the sns_osa_threads list
  NULL otherwise
*/

static sns_osa_thread_x86*
sns_osa_get_current_thread()
{
  pthread_t thread_id = pthread_self();
  sns_isafe_list_iter iter;
  sns_osa_thread_x86 *rv = NULL;

  sns_osa_lock_acquire(sns_osa_threads_lock);
  for(sns_isafe_list_iter_init(&iter, &sns_osa_threads, true);
      NULL != sns_isafe_list_iter_curr(&iter);
      sns_isafe_list_iter_advance(&iter))
  {
    sns_osa_thread_x86 *thread = (sns_osa_thread_x86*)
      sns_isafe_list_iter_get_curr_data(&iter);
    if(thread_id == thread->thread_id)
    {
      rv = thread;
      break;
    }
  }
  sns_osa_lock_release(sns_osa_threads_lock);

  if(NULL == rv)
    SNS_PRINTF(FATAL, sns_fw_printf, "Thread with id %x not found in sns_osa_threads list",
        (uint32_t)thread_id);
  return rv;
}

/*============================================================================
  Public   Functions
  ============================================================================*/

sns_rc
sns_osa_thread_attr_init(sns_osa_thread_attr *attrib)
{
  _Static_assert(sizeof(sns_osa_thread_attr) >= sizeof(sns_osa_thread_x86_attr),
  "__SIZEOF_ATTR_THREAD is smaller than sizeof(sns_osa_thread_x86_attr)");

  if(NULL != attrib)
  {
    sns_osa_thread_x86_attr *pthread_attrib = (sns_osa_thread_x86_attr*)attrib;
    pthread_attr_init(&pthread_attrib->pthread_attrib);
    pthread_attr_setdetachstate(&pthread_attrib->pthread_attrib,
        PTHREAD_CREATE_DETACHED );
    return SNS_RC_SUCCESS;
  }
  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to init osa_thread attribute");
  return SNS_RC_NOT_SUPPORTED;
}

sns_rc
sns_osa_thread_attr_set_stack(
  sns_osa_thread_attr      *attrib,
  uintptr_t                 stack_start,
  size_t                    stack_size)
{

  if(NULL != attrib)
  {
    sns_osa_thread_x86_attr *pthread_attrib = (sns_osa_thread_x86_attr*)attrib;

    if((uintptr_t)NULL != stack_start)
    {
      // We won't actually use this stack. But keep it to preserve memeory use
      UNUSED_VAR(stack_start);
    }
    else
    {
      // We won't actually use this stack. But, we alloc it to preserve memeory use in the heap
      void *stack = sns_malloc(SNS_HEAP_MAIN, stack_size);
      SNS_ASSERT(NULL != stack);
    }

    // Alloc the stack that we will actually use.
    size_t aligned_size = PTHREAD_STACK_MIN + ROUND_UP(stack_size, sysconf(_SC_PAGESIZE)) + STACK_GUARD_SIZE;
    SNS_ASSERT(0 == posix_memalign(&pthread_attrib->real_stack, sysconf(_SC_PAGESIZE), aligned_size));
    SNS_ASSERT(0 == pthread_attr_setstack(&pthread_attrib->pthread_attrib, pthread_attrib->real_stack, aligned_size - STACK_GUARD_SIZE));

    // Remove read and write permissions for the last page size to detect stack overflows
    mprotect(pthread_attrib->real_stack + (aligned_size - STACK_GUARD_SIZE), STACK_GUARD_SIZE, PROT_NONE);

    return SNS_RC_SUCCESS;
  }
  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to set osa_thread stack attribute");
  return SNS_RC_NOT_SUPPORTED;
}

sns_rc
sns_osa_thread_attr_set_priority(sns_osa_thread_attr *attrib, uint8_t priority)
{
  if(NULL != attrib)
  {
    sns_osa_thread_x86_attr *pthread_attrib = (sns_osa_thread_x86_attr*)attrib;
    struct sched_param sched;

    sched.sched_priority = 255 - priority;
    pthread_attr_setschedpolicy(&pthread_attrib->pthread_attrib, SCHED_FIFO);
    pthread_attr_setschedparam(&pthread_attrib->pthread_attrib, &sched);
    return SNS_RC_SUCCESS;
  }

  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to set osa_thread priority attribute");
  return SNS_RC_NOT_SUPPORTED;
}

sns_rc
sns_osa_thread_attr_set_name(sns_osa_thread_attr *attrib, const char *name)
{
  if(NULL != attrib)
  {
    sns_osa_thread_x86_attr *pthread_attrib = (sns_osa_thread_x86_attr*)attrib;
    sns_memscpy(&pthread_attrib->name, SNS_OSA_THREAD_NAME_MAX_LEN, name,
        SNS_OSA_THREAD_NAME_MAX_LEN);
    pthread_attrib->name[SNS_OSA_THREAD_NAME_MAX_LEN - 1] = '\0';
    return SNS_RC_SUCCESS;
  }

  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to set osa_thread name attribute");
  return SNS_RC_NOT_SUPPORTED;
}

sns_rc
sns_osa_thread_attr_set_memory_partition(
  sns_osa_thread_attr    *attrib,
  sns_osa_mem_type       mem_type)
{
  UNUSED_VAR(attrib);
  UNUSED_VAR(mem_type);
  SNS_PRINTF(MED, sns_fw_printf, "Ignoring mem_type attribute for osa_thread");
  return SNS_RC_SUCCESS;
}

sns_rc
sns_osa_thread_attr_set_user_info( sns_osa_thread_attr *attrib, void *info)
{
  if(NULL != attrib)
  {
    sns_osa_thread_x86_attr *pthread_attrib = (sns_osa_thread_x86_attr*)attrib;
    pthread_attrib->user_info = info;
    return SNS_RC_SUCCESS;
  }
  return SNS_RC_NOT_SUPPORTED;
}

sns_rc
sns_osa_thread_create(
  sns_osa_thread_func         thread_func,
  sns_osa_thread_func_arg     thread_func_arg,
  const sns_osa_thread_attr  *attrib,
  sns_osa_thread             **thread)
{
  SNS_ASSERT(NULL != thread_func);
  SNS_ASSERT(NULL != attrib);
  SNS_ASSERT(NULL != thread);

  sns_osa_thread_x86_attr *pthread_attrib = (sns_osa_thread_x86_attr*)attrib;
  sns_osa_thread_x86 *pthread_thread = sns_malloc(SNS_HEAP_ISLAND,
    sizeof(sns_osa_thread_x86));
  sns_isafe_list_iter iter;
  pthread_mutexattr_t mutex_attr;
  pthread_condattr_t cond_attr;
  int err;

  if(NULL != pthread_thread)
  {
    pthread_mutexattr_init(&mutex_attr);
    pthread_condattr_init( &cond_attr );

    pthread_cond_init(&pthread_thread->signals, &cond_attr );
    pthread_mutex_init(&pthread_thread->mutex, &mutex_attr);
    pthread_thread->info = pthread_attrib->user_info;
    sns_isafe_list_item_init(&pthread_thread->list_entry, pthread_thread);
    *thread = (sns_osa_thread*)pthread_thread;

    sns_osa_lock_acquire(sns_osa_threads_lock);
    sns_isafe_list_iter_init(&iter, &sns_osa_threads, false);
    sns_isafe_list_iter_insert(&iter, &pthread_thread->list_entry, true);
    sns_osa_lock_release(sns_osa_threads_lock);

    err = pthread_create(&pthread_thread->thread_id,
        &pthread_attrib->pthread_attrib, (void* (*)(void*))thread_func,
        (void*)thread_func_arg);
    if(0 == err)
    {
      pthread_setname_np(pthread_thread->thread_id, pthread_attrib->name);
      return SNS_RC_SUCCESS;
    }
  }

  *thread = NULL;
  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to set create thread");
  return SNS_RC_NOT_AVAILABLE;
}

sns_rc
sns_osa_thread_delete(sns_osa_thread *thread)
{
  UNUSED_VAR(thread);
  int err;

  if(NULL != thread)
  {
    sns_osa_thread_x86 *pthread_thread = (sns_osa_thread_x86*)thread;
    err = pthread_cancel(pthread_thread->thread_id);
    if(0 == err)
    {
      sns_isafe_list_iter iter;

      sns_osa_lock_acquire(sns_osa_threads_lock);
      sns_isafe_list_iter_init(&iter, &sns_osa_threads, true);
      for(sns_isafe_list_iter_init(&iter, &sns_osa_threads, true);
          NULL != sns_isafe_list_iter_curr(&iter);
          sns_isafe_list_iter_advance(&iter))
      {
        if(pthread_thread == (sns_osa_thread_x86*)sns_isafe_list_iter_get_curr_data(&iter))
        {
          sns_isafe_list_iter_remove(&iter);
        }
      }
      sns_osa_lock_release(sns_osa_threads_lock);
      sns_free(pthread_thread);
      return SNS_RC_SUCCESS;
    }
  }
  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to set delete thread");
  return SNS_RC_INVALID_VALUE;
}

sns_rc
sns_osa_thread_sigs_wait(
  sns_osa_thread_sigs         sigs_mask,
  sns_osa_thread_sigs        *sigs_rcvd)
{
  sns_osa_thread_x86 *thread = sns_osa_get_current_thread();

  SNS_ASSERT(NULL != thread);
  pthread_mutex_lock(&thread->mutex);
  while(0 == (thread->flags & sigs_mask))
  {
    pthread_cond_wait(&thread->signals, &thread->mutex);
  }
  if(NULL != sigs_rcvd)
  {
    *sigs_rcvd = thread->flags & sigs_mask;
  }

  thread->flags = 0;
  pthread_mutex_unlock(&thread->mutex);
  return SNS_RC_SUCCESS;
}

sns_rc
sns_osa_thread_sigs_set(sns_osa_thread *thread, sns_osa_thread_sigs sigs)
{
  if(NULL != thread)
  {
    sns_osa_thread_x86 *pthread_thread = (sns_osa_thread_x86 *) thread;
    pthread_mutex_lock(&pthread_thread->mutex);
    pthread_thread->flags |= sigs;
    pthread_cond_signal(&pthread_thread->signals);
    pthread_mutex_unlock(&pthread_thread->mutex);
    return SNS_RC_SUCCESS;
  }
  SNS_PRINTF(ERROR, sns_fw_printf, "Failed to set signal %d for thread", sigs);
  return SNS_RC_NOT_SUPPORTED;
}


sns_rc sns_osa_thread_sigs_check(
  sns_osa_thread_sigs         sigs_mask,
  bool                        consume,
  sns_osa_thread_sigs        *sigs_rcvd)
{
  sns_osa_thread_x86 *thread = sns_osa_get_current_thread();
  sns_osa_thread_sigs flags = 0;
  SNS_ASSERT(NULL != thread);
  pthread_mutex_lock(&thread->mutex);

  flags = thread->flags & sigs_mask;
  if(NULL != sigs_rcvd)
  {
    if(consume)
    {
      thread->flags ^= flags;
    }
    *sigs_rcvd = flags;
  }
  pthread_mutex_unlock(&thread->mutex);
  return SNS_RC_SUCCESS;
}

uint8_t
sns_osa_thread_get_priority(void)
{
  struct sched_param param;
  int policy;

  pthread_getschedparam(pthread_self(), &policy, &param);
  return param.sched_priority;
}

uint8_t
sns_osa_thread_set_priority(uint8_t priority)
{
  uint8_t old_priority = sns_osa_thread_get_priority();
  pthread_setschedprio(pthread_self(), priority);
  return old_priority;
}

void*
sns_osa_thread_get_user_info()
{
  sns_osa_thread_x86 *thread = sns_osa_get_current_thread();
  SNS_ASSERT(NULL != thread);
  return thread->info;
}

int sns_osa_thread_get_thread_id()
{
  return (int)pthread_self();
}

void
sns_osa_init(void)
{
  sns_osa_lock_attr attr;
  sns_rc rc;

  rc = sns_osa_lock_attr_init(&attr);
  SNS_ASSERT(SNS_RC_SUCCESS == rc);
  rc = sns_osa_lock_attr_set_memory_partition(&attr, SNS_OSA_MEM_TYPE_ISLAND);
  SNS_ASSERT(SNS_RC_SUCCESS == rc);
  rc = sns_osa_lock_create(&attr, &sns_osa_threads_lock);
  SNS_ASSERT(SNS_RC_SUCCESS == rc);

  sns_isafe_list_init(&sns_osa_threads);
}

void
sns_osa_thread_active()
{
  // DO NOTHING
}

void
sns_osa_thread_idle()
{
  // DO NOTHING
}
