&PDC_ENABLE_BANK=0x10
&PDC_ENABLE_BANK_OFFSET_DRV=0x10000
&PDC_ENABLE_BANK_OFFSET_BANK=0x4

&PDC_IRQ_CFG=0x110
&PDC_IRQ_CFG_DRV=0x10000
&PDC_IRQ_CFG_IRQ=0x4

&PDC_IRQ_STATUS=0x900
&PDC_IRQ_STATUS_DRV=0x10000
&PDC_IRQ_STATUS_BANK=0x4

&PDC_GP_IRQ_SEL=0x4900
&PDC_GP_IRQ_SEL_OFFSET_GP=0x14

&total_trigger_types=8.
var.new char[&total_trigger_types][16.] \trigger_config
var.assign \trigger_config[0]="Level Low"
var.assign \trigger_config[1]="Rising Edge"
var.assign \trigger_config[2]="Falling Edge"
var.assign \trigger_config[3]="Dual Edge"
var.assign \trigger_config[4]="Level High"
var.assign \trigger_config[5]="Falling Edge"
var.assign \trigger_config[6]="Rising Edge"
var.assign \trigger_config[7]="Dual Edge"

&total_mux_configs=96.
var.new char[&total_mux_configs][16.] \mux_config
var.assign \mux_config[0.]="GPIO 1"
var.assign \mux_config[1.]="GPIO 3"
var.assign \mux_config[2.]="GPIO 5"
var.assign \mux_config[3.]="GPIO 10"
var.assign \mux_config[4.]="GPIO 11"
var.assign \mux_config[5.]="GPIO 20"
var.assign \mux_config[6.]="GPIO 22"
var.assign \mux_config[7.]="GPIO 24"
var.assign \mux_config[8.]="GPIO 26"
var.assign \mux_config[9.]="GPIO 30"
var.assign \mux_config[10.]="Open"
var.assign \mux_config[11.]="GPIO 32"
var.assign \mux_config[12.]="GPIO 34"
var.assign \mux_config[13.]="GPIO 36"
var.assign \mux_config[14.]="GPIO 37"
var.assign \mux_config[15.]="GPIO 38"
var.assign \mux_config[16.]="GPIO 39"
var.assign \mux_config[17.]="GPIO 40"
var.assign \mux_config[18.]="Open"
var.assign \mux_config[19.]="GPIO 43"
var.assign \mux_config[20.]="GPIO 44"
var.assign \mux_config[21.]="GPIO 46"
var.assign \mux_config[22.]="GPIO 48"
var.assign \mux_config[23.]="Open"
var.assign \mux_config[24.]="GPIO 52"
var.assign \mux_config[25.]="GPIO 53"
var.assign \mux_config[26.]="GPIO 54"
var.assign \mux_config[27.]="GPIO 56"
var.assign \mux_config[28.]="GPIO 57"
var.assign \mux_config[29.]="GPIO 58"
var.assign \mux_config[30.]="GPIO 59"
var.assign \mux_config[31.]="GPIO 60"
var.assign \mux_config[32.]="GPIO 61"
var.assign \mux_config[33.]="GPIO 62"
var.assign \mux_config[34.]="GPIO 63"
var.assign \mux_config[35.]="GPIO 64"
var.assign \mux_config[36.]="GPIO 66"
var.assign \mux_config[37.]="GPIO 68"
var.assign \mux_config[38.]="GPIO 71"
var.assign \mux_config[39.]="GPIO 73"
var.assign \mux_config[40.]="GPIO 77"
var.assign \mux_config[41.]="GPIO 78"
var.assign \mux_config[42.]="GPIO 79"
var.assign \mux_config[43.]="GPIO 80"
var.assign \mux_config[44.]="GPIO 84"
var.assign \mux_config[45.]="GPIO 85"
var.assign \mux_config[46.]="GPIO 86"
var.assign \mux_config[47.]="GPIO 88"
var.assign \mux_config[48.]="Open"
var.assign \mux_config[49.]="GPIO 91"
var.assign \mux_config[50.]="GPIO 92"
var.assign \mux_config[51.]="GPIO 95"
var.assign \mux_config[52.]="GPIO 96"
var.assign \mux_config[53.]="GPIO 97"
var.assign \mux_config[54.]="GPIO 101"
var.assign \mux_config[55.]="GPIO 103"
var.assign \mux_config[56.]="GPIO 104"
var.assign \mux_config[57.]="GPIO 108"
var.assign \mux_config[58.]="GPIO 112"
var.assign \mux_config[59.]="GPIO 113"
var.assign \mux_config[60.]="GPIO 115"
var.assign \mux_config[61.]="GPIO 116"
var.assign \mux_config[62.]="GPIO 117"
var.assign \mux_config[63.]="GPIO 118"
var.assign \mux_config[64.]="GPIO 119"
var.assign \mux_config[65.]="GPIO 120"
var.assign \mux_config[66.]="GPIO 121"
var.assign \mux_config[67.]="GPIO 122"
var.assign \mux_config[68.]="GPIO 123"
var.assign \mux_config[69.]="GPIO 124"
var.assign \mux_config[70.]="GPIO 125"
var.assign \mux_config[71.]="GPIO 126"
var.assign \mux_config[72.]="GPIO 127"
var.assign \mux_config[73.]="GPIO 128"
var.assign \mux_config[74.]="GPIO 129"
var.assign \mux_config[75.]="GPIO 130"
var.assign \mux_config[76.]="GPIO 132"
var.assign \mux_config[77.]="GPIO 133"
var.assign \mux_config[78.]="GPIO 145"
var.assign \mux_config[79.]="Open"
var.assign \mux_config[80.]="Open"
var.assign \mux_config[81.]="Open"
var.assign \mux_config[82.]="Open"
var.assign \mux_config[83.]="Open"
var.assign \mux_config[84.]="Open"
var.assign \mux_config[85.]="Open"
var.assign \mux_config[86.]="Open"
var.assign \mux_config[87.]="Open"
var.assign \mux_config[88.]="Open"
var.assign \mux_config[89.]="MPM2"
var.assign \mux_config[90.]="MPM3"
var.assign \mux_config[91.]="MPM4"
var.assign \mux_config[92.]="GPIO 41"
var.assign \mux_config[93.]="GPIO 89"
var.assign \mux_config[94.]="GPIO 31"
var.assign \mux_config[95.]="GPIO 49"


&access_mode="EZAXI"
&num_subsystems=10.
&str_size=16.

&pdc_data_base=0
&pdc_data_num_muxes=1
&pdc_data_num_ints=2
&pdc_data_num_drv=3
&pdc_data_max=4

var.new int[&num_subsystems][&pdc_data_max] \pdc_data
var.new char[&num_subsystems][&str_size] \pdc_name

var.assign \pdc_name[0.]="APPS"
var.assign \pdc_data[0.][&pdc_data_base]=0x0B200000
var.assign \pdc_data[0.][&pdc_data_num_muxes]=0.
var.assign \pdc_data[0.][&pdc_data_num_ints]=126.
var.assign \pdc_data[0.][&pdc_data_num_drv]=3.

var.assign \pdc_name[1.]="SPSS"
var.assign \pdc_data[1.][&pdc_data_base]=0x0B230000
var.assign \pdc_data[1.][&pdc_data_num_muxes]=10.
var.assign \pdc_data[1.][&pdc_data_num_ints]=20.
var.assign \pdc_data[1.][&pdc_data_num_drv]=1.

var.assign \pdc_name[2.]="AUDIO"
var.assign \pdc_data[2.][&pdc_data_base]=0x0B240000
var.assign \pdc_data[2.][&pdc_data_num_muxes]=10.
var.assign \pdc_data[2.][&pdc_data_num_ints]=20.
var.assign \pdc_data[2.][&pdc_data_num_drv]=1.

var.assign \pdc_name[3.]="SENSORS"
var.assign \pdc_data[3.][&pdc_data_base]=0x0B250000
var.assign \pdc_data[3.][&pdc_data_num_muxes]=20.
var.assign \pdc_data[3.][&pdc_data_num_ints]=75.
var.assign \pdc_data[3.][&pdc_data_num_drv]=1.

var.assign \pdc_name[4.]="AOP"
var.assign \pdc_data[4.][&pdc_data_base]=0x0B260000
var.assign \pdc_data[4.][&pdc_data_num_muxes]=10.
var.assign \pdc_data[4.][&pdc_data_num_ints]=25.
var.assign \pdc_data[4.][&pdc_data_num_drv]=1.

var.assign \pdc_name[5.]="DEBUG"
var.assign \pdc_data[5.][&pdc_data_base]=0x0B270000
var.assign \pdc_data[5.][&pdc_data_num_muxes]=0.
var.assign \pdc_data[5.][&pdc_data_num_ints]=0.
var.assign \pdc_data[5.][&pdc_data_num_drv]=0.

var.assign \pdc_name[6.]="GPU"
var.assign \pdc_data[6.][&pdc_data_base]=0x0B280000
var.assign \pdc_data[6.][&pdc_data_num_muxes]=0.
var.assign \pdc_data[6.][&pdc_data_num_ints]=0.
var.assign \pdc_data[6.][&pdc_data_num_drv]=0.

var.assign \pdc_name[7.]="DISPLAY"
var.assign \pdc_data[7.][&pdc_data_base]=0x0B290000
var.assign \pdc_data[7.][&pdc_data_num_muxes]=0.
var.assign \pdc_data[7.][&pdc_data_num_ints]=0.
var.assign \pdc_data[7.][&pdc_data_num_drv]=0.

var.assign \pdc_name[8.]="MODEM"
var.assign \pdc_data[8.][&pdc_data_base]=0x0B2A0000
var.assign \pdc_data[8.][&pdc_data_num_muxes]=30.
var.assign \pdc_data[8.][&pdc_data_num_ints]=45.
var.assign \pdc_data[8.][&pdc_data_num_drv]=2.

var.assign \pdc_name[9.]="COMPUTE"
var.assign \pdc_data[9.][&pdc_data_base]=0x0B2C0000
var.assign \pdc_data[9.][&pdc_data_num_muxes]=10.
var.assign \pdc_data[9.][&pdc_data_num_ints]=20.
var.assign \pdc_data[9.][&pdc_data_num_drv]=1.


AREA.RESet
WINPOS 0. 0. 100% 100%
AREA.Create PDC
AREA.view PDC


on error gosub
(
  print "An Error has Occured"
  goto UberLoop
)


AREA.CLEAR PDC
AREA.view PDC
AREA.Select PDC


ENTRY &subsystem

gosub AutoDetectConfig

UberLoop:
print ""
print "***********************************"
print "              Menu                 "
print "***********************************"
print " 0) Exit Script                    "
print " 1) Configure PDC Interrupt        "
print " 2) Get PDC Interupt Configuration "
print " 3) Autodetect Configuration       "
print ""
print " Please select an option:          "
ENTER &user_option

if (&user_option==0.)
(
  ; Exit Script
  enddo
)

if (&user_option==1.)
(
  LOCAL &ss_name &iter &config_ss &config_int &config_en &config_trig &config_drv &config_mux
  ; Configure PDC Interrupt
  print ""

  ; Select subsystem
  &iter=0.
  while (&iter<&num_subsystems)
  (
    &ss_name=var.string(\pdc_name[&iter])
    print "&iter: &ss_name"
    &iter=&iter+1
  )
  print "Select Subsystem:"
  ENTER &config_ss
  if (&config_ss>&num_subsystems)
  (
    print "Input error! Back to main menu..."
    goto UberLoop
  )
  print ""

  ; Display total interrupts and muxes
  &ss_interrupts=0.
  &ss_interrupts=format.decimal(1.,v.value(\pdc_data[&config_ss][&pdc_data_num_ints]))
  &ss_total_muxes=0.
  &ss_total_muxes=format.decimal(1.,v.value(\pdc_data[&config_ss][&pdc_data_num_muxes]))
  &ss_name=var.string(\pdc_name[&config_ss])
  print "&ss_name has &ss_interrupts, the upper &ss_total_muxes are muxes"
  print "Please select an interrupt number:"
  ENTER &config_int
  &config_int=&config_int.
  if (&config_int>&ss_interrupts)
  (
    print "Input error! Back to main menu..."
    goto UberLoop
  )
  print ""
  

  ; Check if we want to enable it
  print "0 : Disable"
  print "1 : Enable"
  print "Select Enable Value:"
  ENTER &config_en
  &config_en=&config_en.
  if (&config_en!=0&&&config_en!=1)
  (
    print "Input error! Back to main menu..."
    goto UberLoop
  )
  print ""

  ; Select Trigger Type
  &iter=0.
  while (&iter<&total_trigger_types)
  (
    &trig=var.string(\trigger_config[&iter])
    print "&iter : &trig"
    &iter=&iter+1
  )
  print "Select Trigger Type:"
  ENTER &config_trig
  &config_trig=&config_trig.
  if (&config_trig>&total_trigger_types)
  (
    print "Input error! Back to main menu..."
    goto UberLoop
  )
  print ""

  ; Select DRV (If applicable)
  &drv=v.value(\pdc_data[&config_ss][&pdc_data_num_drv])
  if (&drv>1.)
  (
    &iter=0.
    while (&iter<&drv)
    (
      print "&iter: DRV &iter"
      &iter=&iter+1
    )
    print "Select DRV:"
    ENTER &config_drv
    &config_drv=&config_drv.
    if (&config_drv>&drv)
    (
      print "Input error! Back to main menu..."
      goto UberLoop
    )
    print ""
  )
  else
  (
    &config_drv=0.
  )

  print "Before int: &config_int ss_ints: &ss_interrupts ss_total_muxes: &ss_total_muxes"
  &ss_interrupts=format.decimal(1.,v.value(\pdc_data[&config_ss][&pdc_data_num_ints]))
  &ss_interrupts=&ss_interrupts.
  &ss_total_muxes=format.decimal(1.,v.value(\pdc_data[&config_ss][&pdc_data_num_muxes]))
  &ss_total_muxes=&ss_total_muxes.
  print "Before int: &config_int ss_ints: &ss_interrupts ss_total_muxes: &ss_total_muxes"
  ; Select MUX Input (If applicable)
  if ((&ss_total_muxes>0.)&&(&config_int>=(&ss_interrupts-&ss_total_muxes)))
  (
    ; Config mux
    &iter=0.
    while (&iter<&total_mux_configs)
    (
      &mux_input0=var.string(\mux_config[&iter])
      &mux_input1=var.string(\mux_config[&iter+1.])
      &mux_input2=var.string(\mux_config[&iter+2.])
      &mux_input3=var.string(\mux_config[&iter+3.])
      &iterout0=&iter
      &iterout1=&iter+1.
      &iterout2=&iter+2.
      &iterout3=&iter+3.
      &padding0=string.cut("                ", string.len("&mux_input0")+string.len("&iterout0"))
      &padding1=string.cut("                ", string.len("&mux_input1")+string.len("&iterout1"))
      &padding2=string.cut("                ", string.len("&mux_input2")+string.len("&iterout2"))
      print "&iterout0:&mux_input0&padding0 &iterout1:&mux_input1&padding1 &iterout2:&mux_input2&padding2 &iterout3:&mux_input3"
      &iter=&iter+4.
    )
    print "Select mux Input:"
    ENTER &config_mux
    &config_mux=&config_mux.
    if (&config_mux>&total_mux_configs)
    (
      print "Input error! Back to main menu..."
      goto UberLoop
    )
    print ""
    gosub ConfigMux &config_ss &config_int &config_mux
  )
  gosub ConfigTrigger &config_int &config_ss &config_drv &config_trig
  gosub ConfigEnable &config_int &config_ss &config_drv &config_en
  &out_trig=var.string(\trigger_config[&config_trig])
  print "Completed configuring PDC interrupt &config_int in &ss_name as trigger type &out_trig"
)

if (&user_option==2.)
(
  ; Get PDC Interrupt Configuration
  LOCAL &ss_name &iter &config_ss &config_int &config_en &config_trig &config_drv &config_mux
  ; Configure PDC Interrupt

  ; Select subsystem
  &iter=0.
  while (&iter<&num_subsystems)
  (
    &ss_name=var.string(\pdc_name[&iter])
    print "&iter: &ss_name"
    &iter=&iter+1
  )
  print "Select Subsystem:"
  ENTER &config_ss
  &config_ss=&config_ss.
  if (&config_ss>&num_subsystems)
  (
    print "Input error! Back to main menu..."
    goto UberLoop
  )

  ; Display total interrupts and muxes
  &ss_interrupts=v.value(\pdc_data[&config_ss][&pdc_data_num_ints])
  &ss_total_muxes=v.value(\pdc_data[&config_ss][&pdc_data_num_muxes])
  &ss_name=var.string(\pdc_name[&config_ss])
  print "&ss_name has &ss_interrupts, the upper &ss_total_muxes are muxes"
  print "Please select an interrupt number:"
  ENTER &config_int
  &config_int=&config_int.
  if (&config_int>&ss_interrupts)
  (
    print "Input error! Back to main menu..."
    goto UberLoop
  )
  
  ; Select DRV (If applicable)
  &drv=v.value(\pdc_data[&config_ss][&pdc_data_num_drv])
  if (&drv>1.)
  (
    &iter=0.
    while (&iter<&drv)
    (
      print "&iter: DRV &iter"
      &iter=&iter+1
    )
    print "Select DRV:"
    ENTER &config_drv
    &config_drv=&config_drv.
    if (&config_drv>&drv)
    (
      print "Input error! Back to main menu..."
      goto UberLoop
    )
  )
  else
  (
    &config_drv=0.
  )

  gosub GetConfigEnable &config_int &config_ss &config_drv
  entry &config_en
  print "Enable: &config_en"
  gosub GetConfigTrigger &config_int &config_ss &config_drv
  entry &config_trig
  &trigger_str=var.string(\trigger_config[&config_trig])
  print "Trigger Type: &trigger_str"
  ; Dump MUX Input (If applicable)
  if (&ss_total_muxes>0.&&(&config_int>=(&ss_interrupts-&ss_total_muxes)))
  (
    gosub GetConfigMux &config_ss &config_int
    entry &config_mux
    &config_mux_str=var.string(\mux_config[&config_mux])
    print "Mux Config Select: &config_mux  Input: &config_mux_str"
  )
)

if (&user_option==3.)
(
  gosub AutoDetectConfig
)

goto UberLoop

enddo

PrintStatus:
ENTRY &interrupt &base_address &drv_in &ss_name

&bank=&interrupt/32
&mask=0x1<<(&interrupt&0x1F)

&status_addr=&base_address+&PDC_IRQ_STATUS+(&PDC_IRQ_STATUS_BANK*&bank)+(&drv_in*&PDC_IRQ_STATUS_DRV)
&status_in=data.long(&access_mode:&status_addr)
if (&status_in&&mask)!=0
(
  print "Interrupt &interrupt is pending in &ss_name PDC for DRV &drv_in"
)

return


PrintConfig:
ENTRY &interrupt &base_address &drv_in &ss_name &ss_index

&mask=0x1<<(&interrupt&0x1F)

&config_addr=&base_address+&PDC_IRQ_CFG+(&PDC_IRQ_CFG_IRQ*&interrupt)+(&drv_in*&PDC_IRQ_CFG_DRV)
&config_in=data.long(&access_mode:&config_addr)
&config_type=var.string(\trigger_config[&config_in])

print "Interrupt &interrupt is configured as &config_type in &ss_name PDC for DRV &drv_in"

&num_muxes=var.value(\pdc_data[&ss_index][&pdc_data_num_muxes])
if &num_muxes!=0.
(
  &indexzero=var.value(\pdc_data[&ss_index][&pdc_data_num_ints])-&num_muxes
  if &interrupt>=&indexzero
  (
    &mux_index=&interrupt-&indexzero
    gosub PrintMuxConfig &mux_index &ss_index &interrupt
  )
)

return

PrintMuxConfig:
ENTRY &mux &ss_index &interrupt

&mux_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])
&mux_addr=&mux_addr+&PDC_GP_IRQ_SEL+(&PDC_GP_IRQ_SEL_OFFSET_GP*&mux)
&mux_in=data.long(&access_mode:&mux_addr)

if &mux_in<&total_mux_configs
(
  &muxstr=var.string(\mux_config[&mux_in])
  print "Interrupt &interrupt mux &mux is configured for select &mux_in for input &muxstr"
)

return


ConfigEnable:
ENTRY &interrupt &ss_index &drv_in &enable

&mask=(&enable&0x1)<<(&interrupt&0x1F)
&bmask=(0x1)<<(&interrupt&0x1F)
&reg=&interrupt/32.
&en_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])+&PDC_ENABLE_BANK+(&reg*&PDC_ENABLE_BANK_OFFSET_BANK)+(&drv_in*&PDC_ENABLE_BANK_OFFSET_DRV)
&enable_reg=data.long(&access_mode:&en_addr)
&enable_reg=&enable_reg&~&bmask
&enable_reg=&enable_reg|&mask
data.set &access_mode:&en_addr %long &enable_reg

return

ConfigTrigger:
ENTRY &interrupt &ss_index &drv_in &trigger

&config_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])+&PDC_IRQ_CFG+(&PDC_IRQ_CFG_IRQ*&interrupt)+(&drv_in*&PDC_IRQ_CFG_DRV)
data.set &access_mode:&config_addr %long &trigger

return

ConfigMux:
ENTRY &ss_index &interrupt &mux_sel

&mux=&interrupt-(var.value(\pdc_data[&ss_index][&pdc_data_num_ints])-var.value(\pdc_data[&ss_index][&pdc_data_num_muxes]))
&mux_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])+&PDC_GP_IRQ_SEL+(&PDC_GP_IRQ_SEL_OFFSET_GP*&mux)
data.set &access_mode:&mux_addr %long &mux_sel

return


GetConfigEnable:
ENTRY &interrupt &ss_index &drv_in

&bmask=(0x1)<<(&interrupt&0x1F)
&reg=&interrupt/32.
&en_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])+&PDC_ENABLE_BANK+(&reg*&PDC_ENABLE_BANK_OFFSET_BANK)+(&drv_in*&PDC_ENABLE_BANK_OFFSET_DRV)
&enable_reg=data.long(&access_mode:&en_addr)
&enable=0.
if ((&enable_reg&&bmask)!=0)
(
  &enable=1.
)

return &enable

GetConfigTrigger:
ENTRY &interrupt &ss_index &drv_in

&config_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])+&PDC_IRQ_CFG+(&PDC_IRQ_CFG_IRQ*&interrupt)+(&drv_in*&PDC_IRQ_CFG_DRV)
&trigger=data.long(&access_mode:&config_addr)

return &trigger

GetConfigMux:
ENTRY &ss_index &interrupt

&mux=&interrupt-(var.value(\pdc_data[&ss_index][&pdc_data_num_ints])-var.value(\pdc_data[&ss_index][&pdc_data_num_muxes]))
&mux_addr=var.value(\pdc_data[&ss_index][&pdc_data_base])+&PDC_GP_IRQ_SEL+(&PDC_GP_IRQ_SEL_OFFSET_GP*&mux)
&mux_sel=data.long(&access_mode:&mux_addr)

return &mux_sel


AutoDetectConfig:

print "***********************************"
print "       Auto Detect Config          "
print "***********************************"

&coolbeans=0

while &coolbeans<&num_subsystems
(
  &ss_name=var.string(\pdc_name[&coolbeans])
  if (str.upper("&subsystem")=="&ss_name")||("&subsystem"=="")
  (
    ; Loop over Enable regs
    &hamburger=0
    &frenchfries=var.value(\pdc_data[&coolbeans][&pdc_data_num_ints])
    &frenchfries=&frenchfries/32.
    &frenchfries=&frenchfries+1

    while &hamburger<&frenchfries
    (
      &base_addr=var.value(\pdc_data[&coolbeans][&pdc_data_base])
      &base_addr_en=&base_addr+&PDC_ENABLE_BANK+(&PDC_ENABLE_BANK_OFFSET_BANK*&hamburger)

      &drv=0
      &total_drv=var.value(\pdc_data[&coolbeans][&pdc_data_num_drv])
      while &drv<&total_drv
      (
        &addr=&base_addr_en+(&drv*&PDC_ENABLE_BANK_OFFSET_DRV)
        &enable_reg=data.long(&access_mode:&addr)
        &en_ind=0
        while &enable_reg!=0
        (
          if (&enable_reg&0x1)!=0
          (
            print ""
            &int=&en_ind+(32.*&hamburger)
            print "Interrupt &int is enabled in &ss_name PDC for DRV &drv"
            gosub PrintStatus &int &base_addr &drv &ss_name
            gosub PrintConfig &int &base_addr &drv &ss_name &coolbeans
          )
          &en_ind=&en_ind+1
          &enable_reg=&enable_reg>>1.
        )
        &drv=&drv+1
      )
      &hamburger=&hamburger+1
    )
  )
  &coolbeans=&coolbeans+1
)

return
